from pathlib import Path
from pymake.common.cmake_version import ECMakeVersion
from pymake.common.project_language import EProjectLanguage
from pymake.core.project import Project
from pymake.generation.basic_generator import BasicGenerator
from pymake.generation.build_script import BuildScript
from pymake.helpers.caller_info import CallerInfo
from pymake.helpers.path_statics import shorten_path
from typing import Iterable

class CMake:
    """
    Primary class used to generate CMake build scripts.
    """
    # Name used for build scripts that are the equivalent of CMakeLists.txt.
    PRIMARY_BUILD_SCRIPT_NAME = "make.py"

    def __init__(self,
        min_version: ECMakeVersion,
        generated_tree_path: str = "./.pymake"):
        """
        Initializes the object.
        @param min_version Minimum CMake version for the build scripts.
        @param generated_tree_path Path to the folder where all CMake build
          scripts generated by PyMake will be placed. If this is a relative
          path, it will be interpreted relative to the path of the script
          invoking this method.
        """
        self._min_version = min_version
        self._call_site = CallerInfo()

        # Path to the top level folder for the project
        self._source_tree_path = Path(self._call_site.file_path).parent

        # Use the folder containing the script constructing this object as the
        #   base path for the project. All other paths will be processed as
        #   paths relative to this path.
        self._generated_tree_path = Path(generated_tree_path)
        if not self._generated_tree_path.is_absolute():
            self._generated_tree_path = Path.joinpath(
                self._source_tree_path,
                Path(generated_tree_path)
            ).resolve()

        # Build script for the top-level CMakeLists.txt
        top_level_build_script = BuildScript(
            "CMakeLists.txt",
            Path(""),
            self._generated_tree_path
        )
        top_level_build_script.add_generator(BasicGenerator(
            f"cmake_minimum_required(VERSION {min_version.to_version_string()})",
            caller_offset=1
        ))

        # Store all build script instances, indexed by the relative path of the
        #   file the build script instance is for
        self._build_scripts = {
            Path(""): top_level_build_script
        }

    def add_project(self,
        project_name: str,
        project_languages: EProjectLanguage | Iterable[EProjectLanguage]) -> Project:
        """
        Adds a new CMake project scope.
        @param project_name Name to assign to the project. Must not be an empty
          string or all whitespace.
        @param project_languages Languages used by the project.
        @throws ValueError thrown if any parameter is invalid.
        """
        return Project(
            self._get_or_add_build_script(),
            project_name,
            project_languages
        )

    def build(self, generate_first: bool = True) -> None:
        """
        Builds the project via CMake.
        @param generate_first Whether `generate()` should be called before
          running the build. This should generally be left unchanged unless
          a call to `generate()` is made before this method is called (or using
          old versions of generated build scripts is acceptable).
        @throws RuntimeError Thrown if the build fails for any reason. Output
          from CMake will have been written to stdout and/or stderr, which
          should contain the error that was encountered.
        """
        if generate_first:
            self.generate()

    def generate(self) -> None:
        """
        Generates the build scripts for the project.
        """
        # Temporary - print the generated file's contents instead of writing
        #   them to disk
        for build_script in self._build_scripts.values():
            print(f"File: {build_script.target_path}")
            print("========================================")
            print(build_script.generate_file_contents(self._source_tree_path))
            print("========================================")
            print()

    def _get_or_add_build_script(self, caller_offset: int = 1):
        """
        Gets the build script instance assigned to the current PyMake script.
        """
        caller_info = CallerInfo(2 + caller_offset)
        build_script_rel_path = shorten_path(
            caller_info.file_path.parent,
            self._source_tree_path
        )

        # If the PyMake script already has a build script instance associated
        #   with it, return it. Otherwise, create a new build script instance
        #   for the PyMake script.
        if build_script_rel_path in self._build_scripts:
            return self._build_scripts[build_script_rel_path]
        else:
            build_script = BuildScript(
                self._get_target_build_script_name(caller_info.file_path.name),
                build_script_rel_path,
                self._generated_tree_path
            )
            self._build_scripts[build_script_rel_path] = build_script
            return build_script

    def _get_target_build_script_name(self, script_name: str) -> str:
        """
        Determines the name of the CMake build script to generate for the script.
        @param script_name Name of the PyMake build script that a CMake build
          script should be generated for. This must contain only the file name
          of the PyMake build script and should not contain any path information.
        @returns The name of the CMake file to generate for the build script.
          This will be a file name only and will not contain path information.
        """
        if script_name == CMake.PRIMARY_BUILD_SCRIPT_NAME:
            return "CMakeLists.txt"
        else:
            return script_name.replace(".py", ".cmake")
