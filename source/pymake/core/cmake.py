from pathlib import Path
from pymake.common.cmake_version import ECMakeVersion
from pymake.common.project_language import EProjectLanguage
from pymake.core.preset import Preset
from pymake.core.project import Project
from pymake.core.project_state import ProjectState
from pymake.generation.basic_generator import BasicGenerator
from pymake.generation.disk_file_writer import DiskFileWriter
from pymake.generation.file_writer import IFileWriter
from pymake.tracing.caller_info import CallerInfo
from pymake.helpers.code_generator import CodeGenerator
import subprocess
import sys
from typing import List, Iterable

class CMake:
    """
    Primary class used to generate CMake build scripts.
    """

    def __init__(self,
        min_version: ECMakeVersion,
        generated_tree_path: str = "./.pymake",
        writer: IFileWriter = DiskFileWriter()):
        """
        Initializes the object.
        @param min_version Minimum CMake version for the build scripts.
        @param generated_tree_path Path to the folder where all CMake build
          scripts generated by PyMake will be placed. If this is a relative
          path, it will be interpreted relative to the path of the script
          invoking this method.
        @param writer Writer to use when processing generated CMake scripts.
        """
        self._min_version = min_version
        self._writer = writer
        self._call_site = CallerInfo(1)

        # Path to the top level folder for the project
        source_tree_path = Path(self._call_site.file_path).parent

        # Use the folder containing the script constructing this object as the
        #   base path for the project. All other paths will be processed as
        #   paths relative to this path.
        generated_tree_abs_path = Path(generated_tree_path)
        if not generated_tree_abs_path.is_absolute():
            generated_tree_abs_path = Path.joinpath(
                source_tree_path,
                Path(generated_tree_path)
            ).resolve()
        self._project_state = ProjectState(
            source_tree_path,
            generated_tree_abs_path
        )

        # List of presets to apply by default
        self._default_presets: List[Preset] = []

        # Generate code for the project
        generator = CodeGenerator()
        generator.open_method("cmake_minimum_required")
        generator.write_method_parameter(
            "VERSION",
            self._min_version.to_version_string()
        )
        generator.close_method()

        # Build script for the top-level CMakeLists.txt
        top_level_build_script = self._project_state.get_or_add_build_script()
        top_level_build_script.add_generator(BasicGenerator(
            generator.code
        ))

    def add_preset(self, preset_name: str) -> Preset:
        """
        Adds a new CMake preset.
        @param preset_name Name of the new preset.
        @throws ValueError Thrown if a preset already exists with the given name.
        """
        # Validate the preset name
        call_site = CallerInfo(1)
        if preset_name in self._project_state.presets:
            prev_call_site = self._project_state.presets[preset_name].call_site
            print(f"Cannot add preset '{preset_name}' defined at " +
                f"'{call_site.file_path}:{call_site.line_number}'",
                file=sys.stderr
            )
            print(f"A preset with the same name was previously added at " +
                f"'{prev_call_site.file_path}:{prev_call_site.line_number}'",
                file=sys.stderr
            )
            raise ValueError(
                f"A preset with the name '{preset_name}' was already added."
            )

        # Create the preset
        preset = Preset(
            preset_name,
            source_dir=self._project_state.source_tree_path,
            generated_dir=self._project_state.generated_tree_path
        )
        self._project_state.presets[preset.preset_name] = preset
        return preset

    def add_project(self,
        project_name: str,
        project_languages: EProjectLanguage | Iterable[EProjectLanguage]) -> Project:
        """
        Adds a new CMake project scope.
        @param project_name Name to assign to the project. Must not be an empty
          string or all whitespace.
        @param project_languages Languages used by the project.
        @throws ValueError thrown if any parameter is invalid.
        """
        return Project(
            self._project_state,
            project_name,
            project_languages
        )

    def build(self, generate_first: bool = True) -> None:
        """
        Builds the project via CMake.
        @param generate_first Whether `generate()` should be called before
          running the build. This should generally be left unchanged unless
          a call to `generate()` is made before this method is called (or using
          old versions of generated build scripts is acceptable).
        @throws RuntimeError Thrown if the build fails for any reason. Output
          from CMake will have been written to stdout and/or stderr, which
          should contain the error that was encountered.
        """
        if generate_first:
            self.generate()

        # Process command line arguments to determine which preset(s) should
        #   be used
        selected_presets: List[Preset] = []
        for name in sys.argv[1:]:
            if name in self._project_state.presets:
                selected_presets.append(self._project_state.presets[name])
            else:
                error_str = f"Error: Unrecognized preset: '{name}'"
                print(error_str, file=sys.stderr)
                raise RuntimeError(error_str)

        if not selected_presets:
            selected_presets = self._default_presets

        if not selected_presets:
            error_str = ("Error: No preset was specified and no default " +
                "preset(s) were set.")
            print(error_str, file=sys.stderr)
            raise RuntimeError(error_str)

        # Get the values to use
        preset_state = selected_presets[0].preset_state
        for preset in selected_presets[1:]:
            preset_state.apply(preset.preset_state)

        # TODO: If the minimum CMake version is at least v3.19, generate a
        #   `CMakePresets.json` file instead.
        if preset_state.binary_dir:
            build_dir = str(preset_state.binary_dir)
        else:
            build_dir = "build"
        if preset_state.install_dir:
            install_dir = preset_state.install_dir
        else:
            install_dir = "_out"

        # Run CMake's configure step
        cmake_configure_cmd = [
            "cmake",
            "-S",
            str(preset_state.generated_dir),
            "-B",
            build_dir,
            # TODO: Remove this if using a preset
            f"-DCMAKE_INSTALL_PREFIX='{install_dir}'"
        ]
        print("Running command: " + ' '.join(cmake_configure_cmd))
        subprocess.run(
            cmake_configure_cmd,
            check=True
        )

        # Run CMake's build step
        cmake_build_cmd = [
            "cmake",
            "--build",
            build_dir,
            "--target",
            "install"
        ]
        print("Running command: " + ' '.join(cmake_configure_cmd))
        subprocess.run(
            cmake_build_cmd,
            check=True
        )

    def generate(self) -> None:
        """
        Generates the build scripts for the project.
        """
        # Generate the CMake build scripts
        for build_script in self._project_state.build_scripts.values():
            self._writer.write_script(
                build_script,
                self._project_state.source_tree_path
            )

        # Generate debugging files for each CMake construct added by the project
        for preset in self._project_state.presets.values():
            self._writer.write_preset(
                preset,
                self._project_state.generated_tree_path
            )

    def set_default_presets(self, presets: Preset | Iterable[Preset]) -> None:
        """
        Sets the default preset(s) to use if none are specified.
        @param presets Presets to use as the default presets.
        """
        if isinstance(presets, Preset):
            presets = [presets]
        self._default_presets = list(presets)
